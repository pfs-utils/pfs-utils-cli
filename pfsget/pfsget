#!/bin/bash

if [ -f $(dirname $0)/pfs ] ;  then
    . $(dirname $0)/pfs
else 
    . $(which pfs) || exit 13 
fi    

#потом распихаем по конфигам
mirror_list=./mirror.lst # список зеркал 
EXT=pfs 				 # расширение для модулей
ALIASES="./alias.cfg"      # файл с алиасами для нечеткого поиска
WORK_DIR="./sfs-get"
INSTALL_DIR="$(aufs-n --raw '$dname_source' |grep modules |head -n1)" # папка куда качается модуль с ключем -i
COLUMN2="Создан" # колонки в файлах списках
COLUMN3="Версия"
COLUMN4="Ревизия"
SORT='2,3'  # возможно есть смысл добавить к ключам
			# например --sort 3,4 (поиск без учета даты)


####### Ф У Н К Ц И И ########################
# $1 файл (локальный, http, ftp)
# $2 файл для сохранения 
# вернет имя файла с путем
getfile() {
	#отдельная функция на случай протоколов недоступных с wget
	geturl() { 
		wget -t 2 -O $2  $1 
	}
	mkdir -p "$(dirname $2)"
	if echo "$1" | egrep -q "^[a-z]{3,4}://[a-z0-9./-]*"; then
    		geturl $1 $2
	else
		[ -f $1 ] && cp -a $1 $2
	fi
	[ $? == 0 ] && echo $2
}

# сделать реполист для локальной папки
# $1 папка
# $2 файл реполист
mkrepolist() {
reponame=$(realpath $1)
mkdir -p $(dirname $2)
: > $2
for a in $(find $reponame -maxdepth 2 -type f -name *.$EXT) ; do
	date=$(ls -la $a --time-style=+%F |cut -d " " -f6)
	echo "$a $date 0 0 $reponame" >> $2 
done
[ -f $2 ] && echo $2
}

# склеивает списки в форматах txt и txt.gz в один
make_full_repolist() {
	:> ${WORK_DIR}/sfs-full-repolist
	for a in $(find ${WORK_DIR}/lists -type f) ; do
		zcat $a  2>/dev/null || cat $a 
	done |sort |uniq >> ${WORK_DIR}/sfs-full-repolist
} 

# поиск модуля с самой свежей версией
# $1 шаблон поиска для grep (ищет только отдельное слово)
find_mods() {
if [ "$2" == new ] ; then
	cat ${WORK_DIR}/sfs-full-repolist | grep -wi "$1" |sort -k$SORT |tail -n1 ## sort -nk2,2 -k3,3
   return
elif [ "$2" == all ] ; then
	cat ${WORK_DIR}/sfs-full-repolist | grep -wi "$1" |sort -k$SORT  | cut -d " " -f1 
fi
}

# поиск по синонимам
# $1 что ищем
# $2 файл с синонимами
find_alias() {
FIND=$(grep -m1 -w "$1" $2 | awk '{print $1'} )
# поиск с учетом ошибок написания если есть agrep
[ -z $FIND -a  "$(which agrep 2>/dev/null)" ] && FIND=$( agrep -I 1 -D 1 -E 1 -w "$1" $2 | head -n 1 | awk '{print $1'})
[ $FIND ] || return
FIND=$(echo $FIND |sed 's/^_//')
LIST=$(grep _${FIND} $2 |sed 's/^_[^\ ]*\ //')
echo ${FIND}:  "$LIST"
}

update_repolists() {
n=1
for a in $(cat $mirror_list) ; do
	echo $a |grep -q "^[[:space:]]*#" && continue
	if [ -d $a ] ; then
		file=$(mkrepolist $a ${WORK_DIR}/lists/${n}.list)
	else
		file=$(getfile $a ${WORK_DIR}/lists/${n}.list)
	fi
	echo "$a --> $file"
	n=$(( $n + 1 ))
done
}

#################### К О Д ##############################
for arg in $@
do
  case "${arg}" in
	"-u" | "--updete-media" ) UPDATE_M="on";;
    "-f" | "--force" ) FORCE="on";;
    "-i" | "--install" ) INSTALL="on";;
    "-l" | "--load" ) LOAD="on";;
    "-o" | "--outdir" ) outdir="on";;
    "-s" | "--search" ) SEARCH="on";;
    "-h" | "--help")  HLP ;exit 1;;
    "-"*[A-Za-z]*) echo "$(basename "$0"): invalid option -- '$(echo ${arg} | tr -d '-')'" >&2; HLP; exit 1;;
    *) if [ "${outdir}" = "on" ]; then OUTDIR="${arg}"
       else sourcelist="${sourcelist} ${arg}"; fi
       outdir="off";;
  esac
done

mkdir -p ${WORK_DIR}/lists

if [ "$UPDATE_M" == "on" -o ! -f ${WORK_DIR}/sfs-full-repolist ] ; then
	echo '#########################################################################'
	update_repolists
	make_full_repolist
	[ -z "$sourcelist" ] && exit
	echo '#########################################################################' 
fi
:> ${WORK_DIR}/download.lst
if [ $FORCE ] ; then
# если -f качаем первый найденный. Можно использвать после поиска с -s 
for reg in $sourcelist ; do
	MODULE=$(find_mods $reg new)
	if [ -z "$MODULE" ] ; then
		echo "Модуль не найден, измените шаблон,повторите поиск"
		exit
	fi
	modpath="$(echo $MODULE |cut -d " " -f1)"
	echo $modpath >> ${WORK_DIR}/download.lst
done
else 
for reg in $sourcelist ; do
	if aufs-n --raw '$bname_source' |grep -w "$reg" ; then
		echo -n "Модуль подходящий под шаблон - $reg - уже подключен: "
		aufs-n --raw '$bname_source' |grep -w "$reg"
		echo "Продолжить (Y/N)"
		read m
		[ "$m" != Y -a "$m" != y ] && continue
	fi
	MODULES=$(find_mods $reg all)
	MODULE=$(find_mods $reg new)
 
	if [ -z "$MODULE" ] ; then
		maybe=$(find_alias $reg $ALIASES)
		if [ -z "$maybe" ] ; then
			echo "$reg Не найден. Измените шаблон,повторите поиск"
		else
			echo "Возможно вы искали:"
			echo $maybe
			echo "Измените шаблон,повторите поиск"
		fi
	else
		if [ $(echo $MODULES |wc -w) -gt 1 ] ; then
			echo -e "\nПодходят под шаблон - $reg:"
			for b in $MODULES ; do echo "==> $b" ; done
		fi
		modpath="$(echo $MODULE |cut -d " " -f1)"
		echo -e "\nВы искали Это?  (Y/N)"
		echo "==> $modpath"
		for c in $(seq $(echo "$MODULE" |wc -w)) ; do
			[ "$c" -eq 1 ] && continue
			eval echo \$COLUMN${c}: "$(echo $MODULE |cut -d " " -f $c)"
		done
		if [ "$SEARCH" == "on" ] ; then d=Y ; else  read d ; fi
		if [ "$d" != Y -a "$d" != y ] ; then
			echo "Уточните шаблон поиска и повторите"
			continue
		fi
		echo $modpath >> ${WORK_DIR}/download.lst
	fi
done
fi
[ "$SEARCH" == "on" ] && exit
[ "INSTALL" == "on" ] && TARGET_PATH=$INSTALL_DIR
[ "$OUTDIR" ] && TARGET_PATH=$OUTDIR
[ "$TARGET_PATH" ] || TARGET_PATH="./"
for a in $(cat ${WORK_DIR}/download.lst) ;do
MOD=$(getfile "$a" $TARGET_PATH/$(basename $a))
echo "==> $(basename $MOD) - загружен успешно" 
[ "$INSTALL" == "on" -o "$LOAD" == "on" ] && pfsload $MOD
aufs-n --raw '$bname_source' |grep -wq "$(basename $MOD)" && echo "==> $(basename $MOD) - подключен успешно"
done
