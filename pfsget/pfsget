#!/bin/bash
#потом распихаем по конфигам
mirror_list=./mirror.lst     # список зеркал 
ALIASES="./alias.cfg"        # файл с алиасами для нечеткого поиска
WORK_DIR="./pfsget_work_dir" # папка для хранения реполистов и проч. /var/lib/pfsget?
INSTALL_DIR="$(aufs-n --raw '$dname_source' |grep modules |head -n1)" # папка куда качается модуль с ключем -i
COLUMN2="Создан" # колонки в файлах списках
COLUMN3="Версия"
COLUMN4="Ревизия"
COLUMN5="Размер"
COLUMN6="Описание"
DEVNULL=''
#формат авто реполиста для локальных папок
#если имя будет нормально парситься заменим ноли на значения
COLUMNS_FORMAT='file:/$a $date 0 0 $size'
SORT='2,3'  # возможно есть смысл добавить к ключам
			# например --sort 3,4 (поиск без учета даты)

# здесь подтянется pfs.cfg и можно переопределить из него переменные 
if [ -f $(dirname $0)/pfs ] ;  then
    . $(dirname $0)/pfs
else 
    . $(which pfs) || exit 13 
fi    

####### Ф У Н К Ц И И ########################

#$1 modname
get_requires() {
	local deplist
	deplist=$(pfsinfo -s $1 |grep ^Dependenses: |sed -e 's/^Dependenses://' -e 's/,/ /g') 
	[ -z "$deplist" ] && return
	echo "$deplist" |sed 's/-\{2,\}//g' >> ${WORK_DIR}/requires.lst
}

# $1 файл (локальный, http, ftp)
# $2 файл для сохранения 
# вернет имя файла с путем
getfile() {
	local file='/' 
	#отдельная функция на случай протоколов недоступных с wget
	geturl() { 
		eval wget -t 2 -O $2  $1 "$DEVNULL" 
	}
	mkdir -p "$(dirname $2)"
	if echo "$1" | egrep -q "^file://[a-z0-9./-]*" ; then
		file=$(echo $1 |sed 's#^file:/##')
	elif echo "$1" | egrep -q "^[a-z]{3,6}://[a-z0-9./-]*"; then
    	geturl $1 $2
	else
		file="$1"  
	fi
	[ -f "$file" -a "$(realpath "$file")" != "$(realpath "$2")" ] && cp -a "$file" "$2"
	[ -f "$2" ] && echo $2
}

# сделать реполист для локальной папки
# $1 папка
# $2 файл реполист
mkrepolist() {
	local reponame date size 
	reponame=$(realpath $1)
	mkdir -p $(dirname $2)
	: > $2
	for a in $(find $reponame -maxdepth 2 -type f -name *.$EXT) ; do
		date=$(ls -la $a --time-style=+%F |cut -d " " -f6)
		size=$(du -h $a |cut -f1)
		eval echo "$COLUMNS_FORMAT" >> $2 
	done
	[ -f $2 ] && echo $2
}

# склеивает списки в форматах txt и txt.gz в один
make_full_repolist() {
	:> ${WORK_DIR}/sfs-full-repolist
	for a in $(find ${WORK_DIR}/lists -type f) ; do
		zcat $a  2>/dev/null || cat $a 
	done |sort |uniq >> ${WORK_DIR}/sfs-full-repolist
} 

# поиск модуля с самой свежей версией
# $1 шаблон поиска для grep (ищет только отдельное слово)
find_mods() {
	new=$(cat ${WORK_DIR}/sfs-full-repolist | grep -wi "$1" |sort -k$SORT |tail -n1)
if [ "$2" == new ] ; then
	echo "$new" 
	return
elif [ "$2" == all ] ; then
	cat ${WORK_DIR}/sfs-full-repolist | grep -wi "$1" |sort -k$SORT  | grep -v "$new" | cut -d " " -f1 
fi
}

# поиск по синонимам
# $1 что ищем
# $2 файл с синонимами
find_alias() {
FIND=$(grep -m1 -w "$1" $2 | awk '{print $1'} )
# поиск с учетом ошибок написания если есть agrep
[ -z $FIND -a  "$(which agrep 2>/dev/null)" ] && FIND=$( agrep -I 1 -D 1 -E 1 -w "$1" $2 | head -n 1 | awk '{print $1'})
[ $FIND ] || return
FIND=$(echo $FIND |sed 's/^_//')
LIST=$(grep _${FIND} $2 |sed 's/^_[^\ ]*\ //')
echo ${FIND}:  "$LIST"
}

update_repolists() {
n=1
for a in $(cat $mirror_list) ; do
	echo $a |grep -q "^[[:space:]]*#" && continue
	if [ -d $a ] ; then
		file=$(mkrepolist $a ${WORK_DIR}/lists/${n}.list)
	elif [ -f $a ] ; then
		file=$(getfile $a ${WORK_DIR}/lists/${n}.list)
	else 
		file=$(getfile $a ${WORK_DIR}/lists/${n}.list)
		add_repo_path "$file" "$a"
	fi 
	echo "$a --> $file"
	n=$(( $n + 1 ))
done
}

#добавляем пути до репы в реполист
#$1 локальный реполист
#$2 реполист с путем до сервера
add_repo_path() {
	local path tmpfile
	path=$(dirname $2)
	# если не нужны листы в формате gz можно sed -i (без временного файлв)
	tmpfile="${1}_tmp"
	zcat $1 > $tmpfile || cp $1 $tmpfile
	sed -r '/^[a-z]{3,6}:\/\//!s#^#'$path'/#' "$tmpfile" > $1
	rm "$tmpfile"
}

#################### К О Д ##############################
for arg in $@
do
  case "${arg}" in
	"-u" | "--updete-media" ) UPDATE_M="on";;
    "-f" | "--force" ) FORCE="on";;
    "-i" | "--install" ) INSTALL="on";;
    "-l" | "--load" ) LOAD="on";;
    "-o" | "--outdir" ) outdir="on";;
    "-s" | "--search" ) SEARCH="on";;
    "-g" | "--guimode" ) GUIMODE="on";;
    "-h" | "--help")  HLP ;exit 1;;
    "-"*[A-Za-z]*) echo "$(basename "$0"): invalid option -- '$(echo ${arg} | tr -d '-')'" >&2; HLP; exit 1;;
    *) if [ "${outdir}" = "on" ]; then OUTDIR="${arg}"
       else sourcelist="${sourcelist} ${arg}"; fi
       outdir="off";;
  esac
done

[ "$GUIMODE" = "on" ] && DEVNULL="2>/dev/null"

mkdir -p ${WORK_DIR}/lists

# если ключ -u или холодный старт создаем списки
if [ "$UPDATE_M" == "on" -o ! -f ${WORK_DIR}/sfs-full-repolist ] ; then
	echo '#########################################################################'
	update_repolists
	make_full_repolist
	[ -z "$sourcelist" ] && exit
	echo '#########################################################################' 
fi
#Обнуляем списки загрузки
:> ${WORK_DIR}/download.lst
:> ${WORK_DIR}/requires.lst
for reg in $sourcelist ; do
	MODPATH=''; MODULE=''; MODULES=''; MAYBE='' 
	AUFS_FOUND=$(aufs-n --raw '$bname_source' |grep -w "$reg")
	[ -f "$reg" ] && MODULE="$reg"
	[ ! -f "$reg" ] && MODULE=$(find_mods $reg new)
	[ ! -f "$reg" ] && MODULES=$(find_mods $reg all)
	[ -z "$MODULE" ] && MAYBE=$(find_alias $reg $ALIASES)
	MODPATH="$(echo $MODULE |cut -d " " -f1)" 
	if [ "$FORCE" = "on" ] ; then
		if [ -z "$MODULE" ] ; then
			echo "Модуль не найден, измените шаблон,повторите поиск"
			exit
		fi
		echo $MODPATH >> ${WORK_DIR}/download.lst
	elif [ "$GUIMODE" = "on" ] ; then
		echo "maybe:>> $MAYBE"  
		echo "new:>> $MODPATH"
		for b in $MODULES ; do echo "old:>> $b" ; done
		echo "$MODPATH" >> ${WORK_DIR}/download.lst
	else
		if [ -z "$MODULE" ] ; then
			if [ -z "$MAYBE" ] ; then
				echo "$reg Не найден в репозитории. Измените шаблон,повторите поиск"
			else
				echo "Возможно вы искали:"
				echo "==> $MAYBE"
				echo "Измените шаблон,повторите поиск"
			fi
		else
			if [ $(echo $MODULES |wc -w) -gt 1 ] ; then
				echo -e "\nПодходят под шаблон - $reg:"
				for b in $MODULES ; do echo "==> $b" ; done
			fi
			echo ''
			echo -e "\nНайден модуль, продолжить?  (Y/N)"
			echo "==> $MODPATH"
			for c in $(seq $(echo "$MODULE" |wc -w)) ; do
				[ "$c" -eq 1 ] && continue
				eval echo \$COLUMN${c}: "$(echo $MODULE |cut -d " " -f $c)"
			done
			if [ "$SEARCH" == "on" ] ; then d=Y ; else  read d ; fi
			if [ "$d" != Y -a "$d" != y ] ; then
				echo "Уточните шаблон поиска и повторите"
				continue
			fi	
		fi
	echo "$MODPATH" >> ${WORK_DIR}/download.lst
	fi
done

[ "$SEARCH" = "on" ] && exit
[ "$INSTALL" = "on" ] && TARGET_PATH=$INSTALL_DIR
[ "$OUTDIR" ] && TARGET_PATH=$OUTDIR
[ "$TARGET_PATH" ] || TARGET_PATH="./"
for a in $(cat ${WORK_DIR}/download.lst) ;do
	MOD=''
	MOD=$(getfile "$a" $TARGET_PATH/$(basename $a))
	if  [ -f "$MOD" ] ; then
		[ "$GUIMODE" != "on" ] && echo "==> $(basename $MOD) - загружен успешно"
		[ "$GUIMODE" = "on" ] && echo "download:>> $MOD"
	else
		[ "$GUIMODE" != "on" ] && echo "==> $(basename $MOD) - ошибка загрузки!!!"
	fi
	get_requires $MOD 
	
	if [ "$INSTALL" == "on" -o "$LOAD" == "on" ] ; then 
		pfsload "$MOD"
		if 	aufs-n --raw '$bname_source' |grep -wq "$(basename $MOD)" ; then
			[ "$GUIMODE" != "on" ] && echo "==> $(basename $MOD) - подключен успешно"
			[ "$GUIMODE" = "on" ] && echo "pfsload:>> $MOD"
		else
			[ "$GUIMODE" != "on" ] && echo "==> $(basename $MOD) - ошибка подключения!!!"
		fi
	fi
done
if ! [ -z "$(cat ${WORK_DIR}/requires.lst)" ] ;then
	reqlist=''
	for req in $(cat ${WORK_DIR}/requires.lst) ; do
		aufs-n --raw '$bname_source' |grep -wq "$req" && continue
		find $TARGET_PATH -maxdepth 1 -type f -name "*${req}*" |grep -wq "$req" && continue
		reqlist="$reqlist $req"
	done
	L=''
	[ "$INSTALL" == "on" -o "$LOAD" == "on" ] && L="-l"
	if [ -n "$reqlist" ] ; then
		eval echo "Загружаем зависимости: $reqlist" $DEVNULL
		$0 $L -f -o $TARGET_PATH $reqlist
	fi  
fi
